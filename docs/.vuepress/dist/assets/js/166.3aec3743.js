(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{553:function(e,a,s){"use strict";s.r(a);var n=s(45),v=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"vue-常考基础知识点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-常考基础知识点"}},[e._v("#")]),e._v(" Vue 常考基础知识点")]),e._v(" "),s("p",[e._v("这一章节我们将来学习 Vue 的一些经常考到的基础知识点。")]),e._v(" "),s("h2",{attrs:{id:"生命周期钩子函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子函数"}},[e._v("#")]),e._v(" 生命周期钩子函数")]),e._v(" "),s("p",[e._v("在 "),s("code",[e._v("beforeCreate")]),e._v(" 钩子函数调用的时候，是获取不到 "),s("code",[e._v("props")]),e._v(" 或者 "),s("code",[e._v("data")]),e._v(" 中的数据的，因为这些数据的初始化都在 "),s("code",[e._v("initState")]),e._v(" 中。")]),e._v(" "),s("p",[e._v("然后会执行 "),s("code",[e._v("created")]),e._v(" 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。")]),e._v(" "),s("p",[e._v("接下来会先执行 "),s("code",[e._v("beforeMount")]),e._v(" 钩子函数，开始创建 VDOM，最后执行 "),s("code",[e._v("mounted")]),e._v(" 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。")]),e._v(" "),s("p",[e._v("接下来是数据更新时会调用的钩子函数 "),s("code",[e._v("beforeUpdate")]),e._v(" 和 "),s("code",[e._v("updated")]),e._v("，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。")]),e._v(" "),s("p",[e._v("另外还有 "),s("code",[e._v("keep-alive")]),e._v(" 独有的生命周期，分别为 "),s("code",[e._v("activated")]),e._v(" 和 "),s("code",[e._v("deactivated")]),e._v(" 。用 "),s("code",[e._v("keep-alive")]),e._v(" 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 "),s("code",[e._v("deactivated")]),e._v(" 钩子函数，命中缓存渲染后会执行 "),s("code",[e._v("actived")]),e._v(" 钩子函数。")]),e._v(" "),s("p",[e._v("最后就是销毁组件的钩子函数 "),s("code",[e._v("beforeDestroy")]),e._v(" 和 "),s("code",[e._v("destroyed")]),e._v("。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 "),s("code",[e._v("destroyed")]),e._v(" 钩子函数。")]),e._v(" "),s("h2",{attrs:{id:"组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[e._v("#")]),e._v(" 组件通信")]),e._v(" "),s("p",[e._v("组件通信一般分为以下几种情况：")]),e._v(" "),s("ul",[s("li",[e._v("父子组件通信")]),e._v(" "),s("li",[e._v("兄弟组件通信")]),e._v(" "),s("li",[e._v("跨多层级组件通信")]),e._v(" "),s("li",[e._v("任意组件")])]),e._v(" "),s("p",[e._v("对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。")]),e._v(" "),s("h3",{attrs:{id:"父子通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父子通信"}},[e._v("#")]),e._v(" 父子通信")]),e._v(" "),s("p",[e._v("父组件通过 "),s("code",[e._v("props")]),e._v(" 传递数据给子组件，子组件通过 "),s("code",[e._v("emit")]),e._v(" 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。")]),e._v(" "),s("p",[e._v("这种父子通信方式也就是典型的单向数据流，父组件通过 "),s("code",[e._v("props")]),e._v(" 传递数据，子组件不能直接修改 "),s("code",[e._v("props")]),e._v("， 而是必须通过发送事件的方式告知父组件修改数据。")]),e._v(" "),s("p",[e._v("另外这两种方式还可以使用语法糖 "),s("code",[e._v("v-model")]),e._v(" 来直接实现，因为 "),s("code",[e._v("v-model")]),e._v(" 默认会解析成名为 "),s("code",[e._v("value")]),e._v(" 的 "),s("code",[e._v("prop")]),e._v(" 和名为 "),s("code",[e._v("input")]),e._v(" 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。")]),e._v(" "),s("p",[e._v("当然我们还可以通过访问 "),s("code",[e._v("$parent")]),e._v(" 或者 "),s("code",[e._v("$children")]),e._v(" 对象来访问组件实例中的方法和数据。")]),e._v(" "),s("p",[e._v("另外如果你使用 Vue 2.3 及以上版本的话还可以使用 "),s("code",[e._v("$listeners")]),e._v(" 和 "),s("code",[e._v(".sync")]),e._v(" 这两个属性。")]),e._v(" "),s("p",[s("code",[e._v("$listeners")]),e._v(" 属性会将父组件中的 (不含 "),s("code",[e._v(".native")]),e._v(" 修饰器的) "),s("code",[e._v("v-on")]),e._v(" 事件监听器传递给子组件，子组件可以通过访问 "),s("code",[e._v("$listeners")]),e._v(" 来自定义监听器。")]),e._v(" "),s("p",[s("code",[e._v(".sync")]),e._v(" 属性是个语法糖，可以很简单的实现子组件与父组件通信")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('\x3c!--父组件中--\x3e\n<input :value.sync="value" />\n\x3c!--以上写法等同于--\x3e\n<input :value="value" @update:value="v => value = v"></comp>\n\x3c!--子组件中--\x3e\n<script>\n  this.$emit(\'update:value\', 1)\n<\/script>\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("h3",{attrs:{id:"兄弟组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件通信"}},[e._v("#")]),e._v(" 兄弟组件通信")]),e._v(" "),s("p",[e._v("对于这种情况可以通过查找父组件中的子组件实现，也就是 "),s("code",[e._v("this.$parent.$children")]),e._v("，在 "),s("code",[e._v("$children")]),e._v(" 中可以通过组件 "),s("code",[e._v("name")]),e._v(" 查询到需要的组件实例，然后进行通信。")]),e._v(" "),s("h3",{attrs:{id:"跨多层次组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨多层次组件通信"}},[e._v("#")]),e._v(" 跨多层次组件通信")]),e._v(" "),s("p",[e._v("对于这种情况可以使用 Vue 2.2 新增的 API "),s("code",[e._v("provide / inject")]),e._v("，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。")]),e._v(" "),s("p",[e._v("假设有父组件 A，然后有一个跨多层级的子组件 B")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 父组件 A\nexport default {\n  provide: {\n    data: 1\n  }\n}\n// 子组件 B\nexport default {\n  inject: ['data'],\n  mounted() {\n    // 无论跨几层都能获得父组件的 data 属性\n    console.log(this.data) // => 1\n  }\n}\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("h3",{attrs:{id:"任意组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任意组件"}},[e._v("#")]),e._v(" 任意组件")]),e._v(" "),s("p",[e._v("这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况")]),e._v(" "),s("h2",{attrs:{id:"extend-能做什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extend-能做什么"}},[e._v("#")]),e._v(" extend 能做什么")]),e._v(" "),s("p",[e._v("这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 "),s("code",[e._v("$mount")]),e._v(" 一起使用。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 创建组件构造器\nlet Component = Vue.extend({\n  template: '<div>test</div>'\n})\n// 挂载到 #app 上\nnew Component().$mount('#app')\n// 除了上面的方式，还可以用来扩展已有的组件\nlet SuperComponent = Vue.extend(Component)\nnew SuperComponent({\n    created() {\n        console.log(1)\n    }\n})\nnew SuperComponent().$mount('#app')\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("h2",{attrs:{id:"mixin-和-mixins-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mixin-和-mixins-区别"}},[e._v("#")]),e._v(" mixin 和 mixins 区别")]),e._v(" "),s("p",[s("code",[e._v("mixin")]),e._v(" 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Vue.mixin({\n    beforeCreate() {\n        // ...逻辑\n        // 这种方式会影响到每个组件的 beforeCreate 钩子函数\n    }\n})\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("虽然文档不建议我们在应用中直接使用 "),s("code",[e._v("mixin")]),e._v("，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 "),s("code",[e._v("ajax")]),e._v(" 或者一些工具函数等等。")]),e._v(" "),s("p",[s("code",[e._v("mixins")]),e._v(" 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 "),s("code",[e._v("mixins")]),e._v(" 混入代码，比如上拉下拉加载数据这种逻辑等等。")]),e._v(" "),s("p",[e._v("另外需要注意的是 "),s("code",[e._v("mixins")]),e._v(" 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 "),s("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/mixins.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),s("OutboundLink")],1),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"computed-和-watch-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-区别"}},[e._v("#")]),e._v(" computed 和 watch 区别")]),e._v(" "),s("p",[s("code",[e._v("computed")]),e._v(" 是计算属性，依赖其他属性计算值，并且 "),s("code",[e._v("computed")]),e._v(" 的值有缓存，只有当计算值变化才会返回内容。")]),e._v(" "),s("p",[s("code",[e._v("watch")]),e._v(" 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。")]),e._v(" "),s("p",[e._v("所以一般来说需要依赖别的属性来动态获得值的时候可以使用 "),s("code",[e._v("computed")]),e._v("，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 "),s("code",[e._v("watch")]),e._v("。")]),e._v(" "),s("p",[e._v("另外 "),s("code",[e._v("computed")]),e._v(" 和 "),s("code",[e._v("watch")]),e._v(" 还都支持对象的写法，这种方式知道的人并不多。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("vm.$watch('obj', {\n    // 深度遍历\n    deep: true,\n    // 立即触发\n    immediate: true,\n    // 执行的函数\n    handler: function(val, oldVal) {}\n})\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aPlus: {\n      // this.aPlus 时触发\n      get: function () {\n        return this.a + 1\n      },\n      // this.aPlus = 1 时触发\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br")])]),s("h2",{attrs:{id:"keep-alive-组件有什么作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-组件有什么作用"}},[e._v("#")]),e._v(" keep-alive 组件有什么作用")]),e._v(" "),s("p",[e._v("如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 "),s("code",[e._v("keep-alive")]),e._v(" 组件包裹需要保存的组件。")]),e._v(" "),s("p",[e._v("对于 "),s("code",[e._v("keep-alive")]),e._v(" 组件来说，它拥有两个独有的生命周期钩子函数，分别为 "),s("code",[e._v("activated")]),e._v(" 和 "),s("code",[e._v("deactivated")]),e._v(" 。用 "),s("code",[e._v("keep-alive")]),e._v(" 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 "),s("code",[e._v("deactivated")]),e._v(" 钩子函数，命中缓存渲染后会执行 "),s("code",[e._v("actived")]),e._v(" 钩子函数。")]),e._v(" "),s("h2",{attrs:{id:"v-show-与-v-if-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-show-与-v-if-区别"}},[e._v("#")]),e._v(" v-show 与 v-if 区别")]),e._v(" "),s("p",[s("code",[e._v("v-show")]),e._v(" 只是在 "),s("code",[e._v("display: none")]),e._v(" 和 "),s("code",[e._v("display: block")]),e._v(" 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 "),s("code",[e._v("v-show")]),e._v(" 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。")]),e._v(" "),s("p",[s("code",[e._v("v-if")]),e._v(" 的话就得说到 Vue 底层的编译了。当属性初始为 "),s("code",[e._v("false")]),e._v(" 时，组件就不会被渲染，直到条件为 "),s("code",[e._v("true")]),e._v("，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。")]),e._v(" "),s("p",[e._v("并且基于 "),s("code",[e._v("v-if")]),e._v(" 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。")]),e._v(" "),s("h2",{attrs:{id:"组件中-data-什么时候可以使用对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件中-data-什么时候可以使用对象"}},[e._v("#")]),e._v(" 组件中 data 什么时候可以使用对象")]),e._v(" "),s("p",[e._v("这道题目其实更多考的是 JS 功底。")]),e._v(" "),s("p",[e._v("组件复用时所有组件实例都会共享 "),s("code",[e._v("data")]),e._v("，如果 "),s("code",[e._v("data")]),e._v(" 是对象的话，就会造成一个组件修改 "),s("code",[e._v("data")]),e._v(" 以后会影响到其他所有组件，所以需要将 "),s("code",[e._v("data")]),e._v(" 写成函数，每次用到就调用一次函数获得新的数据。")]),e._v(" "),s("p",[e._v("当我们使用 "),s("code",[e._v("new Vue()")]),e._v(" 的方式的时候，无论我们将 "),s("code",[e._v("data")]),e._v(" 设置为对象还是函数都是可以的，因为 "),s("code",[e._v("new Vue()")]),e._v(" 的方式是生成一个根组件，该组件不会复用，也就不存在共享 "),s("code",[e._v("data")]),e._v(" 的情况了。")]),e._v(" "),s("h1",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("总的来说这一章节的内容更多的偏向于 Vue 的基础，下一章节我们将来了解一些原理性方面的知识。")])])}),[],!1,null,null,null);a.default=v.exports}}]);