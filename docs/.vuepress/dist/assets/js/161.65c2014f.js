(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{548:function(s,n,e){"use strict";e.r(n);var a=e(45),t=Object(a.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"js-进阶知识点及常考面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-进阶知识点及常考面试题"}},[s._v("#")]),s._v(" JS 进阶知识点及常考面试题")]),s._v(" "),e("p",[s._v("在这一章节中，我们将会学习到一些原理相关的知识，不会解释涉及到的知识点的作用及用法，如果大家对于这些内容还不怎么熟悉，推荐先去学习相关的知识点内容再来学习原理知识。")]),s._v(" "),e("h2",{attrs:{id:"手写-call、apply-及-bind-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写-call、apply-及-bind-函数"}},[s._v("#")]),s._v(" 手写 call、apply 及 bind 函数")]),s._v(" "),e("blockquote",[e("p",[s._v("涉及面试题：call、apply 及 bind 函数内部实现是怎么样的？")])]),s._v(" "),e("p",[s._v("首先从以下几点来考虑如何实现这几个函数")]),s._v(" "),e("ul",[e("li",[s._v("不传入第一个参数，那么上下文默认为 "),e("code",[s._v("window")])]),s._v(" "),e("li",[s._v("改变了 "),e("code",[s._v("this")]),s._v(" 指向，让新的对象可以执行该函数，并能接受参数")])]),s._v(" "),e("p",[s._v("那么我们先来实现 "),e("code",[s._v("call")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Function.prototype.myCall = function(context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  context = context || window\n  context.fn = this\n  const args = [...arguments].slice(1)\n  const result = context.fn(...args)\n  delete context.fn\n  return result\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("p",[s._v("以下是对实现的分析：")]),s._v(" "),e("ul",[e("li",[s._v("首先 "),e("code",[s._v("context")]),s._v(" 为可选参数，如果不传的话默认上下文为 "),e("code",[s._v("window")])]),s._v(" "),e("li",[s._v("接下来给 "),e("code",[s._v("context")]),s._v(" 创建一个 "),e("code",[s._v("fn")]),s._v(" 属性，并将值设置为需要调用的函数")]),s._v(" "),e("li",[s._v("因为 "),e("code",[s._v("call")]),s._v(" 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来")]),s._v(" "),e("li",[s._v("然后调用函数并将对象上的函数删除")])]),s._v(" "),e("p",[s._v("以上就是实现 "),e("code",[s._v("call")]),s._v(" 的思路，"),e("code",[s._v("apply")]),s._v(" 的实现也类似，区别在于对参数的处理，所以就不一一分析思路了")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Function.prototype.myApply = function(context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  context = context || window\n  context.fn = this\n  let result\n  // 处理参数和 call 有区别\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br")])]),e("p",[e("code",[s._v("bind")]),s._v(" 的实现对比其他两个函数略微地复杂了一点，因为 "),e("code",[s._v("bind")]),s._v(" 需要返回一个函数，需要判断一些边界问题，以下是 "),e("code",[s._v("bind")]),s._v(" 的实现")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Function.prototype.myBind = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  const _this = this\n  const args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br")])]),e("p",[s._v("以下是对实现的分析：")]),s._v(" "),e("ul",[e("li",[s._v("前几步和之前的实现大相径庭，就不赘述了")]),s._v(" "),e("li",[e("code",[s._v("bind")]),s._v(" 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 "),e("code",[s._v("new")]),s._v(" 的方式，我们先来说直接调用的方式")]),s._v(" "),e("li",[s._v("对于直接调用来说，这里选择了 "),e("code",[s._v("apply")]),s._v(" 的方式实现，但是对于参数需要注意以下情况：因为 "),e("code",[s._v("bind")]),s._v(" 可以实现类似这样的代码 "),e("code",[s._v("f.bind(obj, 1)(2)")]),s._v("，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 "),e("code",[s._v("args.concat(...arguments)")])]),s._v(" "),e("li",[s._v("最后来说通过 "),e("code",[s._v("new")]),s._v(" 的方式，在之前的章节中我们学习过如何判断 "),e("code",[s._v("this")]),s._v("，对于 "),e("code",[s._v("new")]),s._v(" 的情况来说，不会被任何方式改变 "),e("code",[s._v("this")]),s._v("，所以对于这种情况我们需要忽略传入的 "),e("code",[s._v("this")])])]),s._v(" "),e("h2",{attrs:{id:"new"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[s._v("#")]),s._v(" new")]),s._v(" "),e("blockquote",[e("p",[s._v("涉及面试题：new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？")])]),s._v(" "),e("p",[s._v("在调用 "),e("code",[s._v("new")]),s._v(" 的过程中会发生以上四件事情：")]),s._v(" "),e("ol",[e("li",[s._v("新生成了一个对象")]),s._v(" "),e("li",[s._v("链接到原型")]),s._v(" "),e("li",[s._v("绑定 this")]),s._v(" "),e("li",[s._v("返回新对象")])]),s._v(" "),e("p",[s._v("根据以上几个过程，我们也可以试着来自己实现一个 "),e("code",[s._v("new")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function create() {\n  let obj = {}\n  let Con = [].shift.call(arguments)\n  obj.__proto__ = Con.prototype\n  let result = Con.apply(obj, arguments)\n  return result instanceof Object ? result : obj\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("以下是对实现的分析：")]),s._v(" "),e("ul",[e("li",[s._v("创建一个空对象")]),s._v(" "),e("li",[s._v("获取构造函数")]),s._v(" "),e("li",[s._v("设置空对象的原型")]),s._v(" "),e("li",[s._v("绑定 "),e("code",[s._v("this")]),s._v(" 并执行构造函数")]),s._v(" "),e("li",[s._v("确保返回值为对象")])]),s._v(" "),e("p",[s._v("对于对象来说，其实都是通过 "),e("code",[s._v("new")]),s._v(" 产生的，无论是 "),e("code",[s._v("function Foo()")]),s._v(" 还是 "),e("code",[s._v("let a = { b : 1 }")]),s._v(" 。")]),s._v(" "),e("p",[s._v("对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 "),e("code",[s._v("new Object()")]),s._v(" 的方式创建对象需要通过作用域链一层层找到 "),e("code",[s._v("Object")]),s._v("，但是你使用字面量的方式就没这个问题。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function Foo() {}\n// function 就是个语法糖\n// 内部等同于 new Function()\nlet a = { b: 1 }\n// 这个字面量内部也是使用了 new Object()\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h2",{attrs:{id:"instanceof-的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-的原理"}},[s._v("#")]),s._v(" instanceof 的原理")]),s._v(" "),e("blockquote",[e("p",[s._v("涉及面试题：instanceof 的原理是什么？")])]),s._v(" "),e("p",[e("code",[s._v("instanceof")]),s._v(" 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 "),e("code",[s._v("prototype")]),s._v("。")]),s._v(" "),e("p",[s._v("我们也可以试着实现一下 "),e("code",[s._v("instanceof")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function myInstanceof(left, right) {\n  let prototype = right.prototype\n  left = left.__proto__\n  while (true) {\n    if (left === null || left === undefined)\n      return false\n    if (prototype === left)\n      return true\n    left = left.__proto__\n  }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("p",[s._v("以下是对实现的分析：")]),s._v(" "),e("ul",[e("li",[s._v("首先获取类型的原型")]),s._v(" "),e("li",[s._v("然后获得对象的原型")]),s._v(" "),e("li",[s._v("然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 "),e("code",[s._v("null")]),s._v("，因为原型链最终为 "),e("code",[s._v("null")])])]),s._v(" "),e("h2",{attrs:{id:"为什么-0-1-0-2-0-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-0-1-0-2-0-3"}},[s._v("#")]),s._v(" 为什么 0.1 + 0.2 != 0.3")]),s._v(" "),e("blockquote",[e("p",[s._v("涉及面试题：为什么 0.1 + 0.2 != 0.3？如何解决这个问题？")])]),s._v(" "),e("p",[s._v("先说原因，因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。")]),s._v(" "),e("p",[s._v("我们都知道计算机是通过二进制来存储东西的，那么 "),e("code",[s._v("0.1")]),s._v(" 在二进制中会表示为")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// (0011) 表示循环\n0.1 = 2^-4 * 1.10011(0011)\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("我们可以发现，"),e("code",[s._v("0.1")]),s._v(" 在二进制中是无限循环的一些数字，其实不只是 "),e("code",[s._v("0.1")]),s._v("，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。")]),s._v(" "),e("p",[s._v("IEEE 754 双精度版本（64位）将 64 位分为了三段")]),s._v(" "),e("ul",[e("li",[s._v("第一位用来表示符号")]),s._v(" "),e("li",[s._v("接下去的 11 位用来表示指数")]),s._v(" "),e("li",[s._v("其他的位数用来表示有效位，也就是用二进制表示 "),e("code",[s._v("0.1")]),s._v(" 中的 "),e("code",[s._v("10011(0011)")])])]),s._v(" "),e("p",[s._v("那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 "),e("code",[s._v("0.1")]),s._v(" 不再是 "),e("code",[s._v("0.1")]),s._v(" 了，而是变成了 "),e("code",[s._v("0.100000000000000002")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("0.100000000000000002 === 0.1 // true\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("那么同样的，"),e("code",[s._v("0.2")]),s._v(" 在二进制也是无限循环的，被裁剪后也失去了精度变成了 "),e("code",[s._v("0.200000000000000002")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("0.200000000000000002 === 0.2 // true\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("所以这两者相加不等于 "),e("code",[s._v("0.3")]),s._v(" 而是 "),e("code",[s._v("0.300000000000000004")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("0.1 + 0.2 === 0.30000000000000004 // true\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("那么可能你又会有一个疑问，既然 "),e("code",[s._v("0.1")]),s._v(" 不是 "),e("code",[s._v("0.1")]),s._v("，那为什么 "),e("code",[s._v("console.log(0.1)")]),s._v(" 却是正确的呢？")]),s._v(" "),e("p",[s._v("因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("console.log(0.100000000000000002) // 0.1\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("h2",{attrs:{id:"垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[s._v("#")]),s._v(" 垃圾回收机制")]),s._v(" "),e("blockquote",[e("p",[s._v("涉及面试题：V8 下的垃圾回收机制是怎么样的？")])]),s._v(" "),e("p",[s._v("V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。")]),s._v(" "),e("h2",{attrs:{id:"新生代算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新生代算法"}},[s._v("#")]),s._v(" 新生代算法")]),s._v(" "),e("p",[s._v("新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。")]),s._v(" "),e("p",[s._v("在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。")]),s._v(" "),e("h2",{attrs:{id:"老生代算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#老生代算法"}},[s._v("#")]),s._v(" 老生代算法")]),s._v(" "),e("p",[s._v("老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。")]),s._v(" "),e("p",[s._v("在讲算法前，先来说下什么情况下对象会出现在老生代空间中：")]),s._v(" "),e("ul",[e("li",[s._v("新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。")]),s._v(" "),e("li",[s._v("To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。")])]),s._v(" "),e("p",[s._v("老生代中的空间很复杂，有如下几个空间")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("enum AllocationSpace {\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br")])]),e("p",[s._v("在老生代中，以下情况会先启动标记清除算法：")]),s._v(" "),e("ul",[e("li",[s._v("某一个空间没有分块的时候")]),s._v(" "),e("li",[s._v("空间中被对象超过一定限制")]),s._v(" "),e("li",[s._v("空间不能保证新生代中的对象移动到老生代中")])]),s._v(" "),e("p",[s._v("在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 "),e("a",{attrs:{href:"https://v8project.blogspot.com/2018/06/concurrent-marking.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("该博客"),e("OutboundLink")],1),s._v(" 详细阅读。")]),s._v(" "),e("p",[s._v("清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。")]),s._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),e("p",[s._v("以上就是 JS 进阶知识点的内容了，这部分的知识相比于之前的内容更加深入也更加的理论，也是在面试中能够于别的候选者拉开差距的一块内容。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。")])])}),[],!1,null,null,null);n.default=t.exports}}]);