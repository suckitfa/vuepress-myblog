(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{372:function(v,_,t){v.exports=t.p+"assets/img/event-loop.2ff254cb.png"},404:function(v,_,t){"use strict";t.r(_);var s=t(45),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[s("strong",[v._v("什么是宏任务与微任务？")])]),v._v(" "),s("p",[v._v("为了提高CPU的利用效率：Js 有两种任务的执行模式："),s("strong",[v._v("同步模式（Synchronous）和异步模式（Asynchronous）")]),v._v("。")]),v._v(" "),s("p",[v._v("在异步模式下，创建"),s("strong",[v._v("异步任务主要分为宏任务与微任务两种")]),v._v("。")]),v._v(" "),s("ul",[s("li",[v._v("ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。宏任务是由宿主（浏览器、Node）发起的")]),v._v(" "),s("li",[v._v("微任务由 JS 自身发起。")])]),v._v(" "),s("p",[s("strong",[v._v("宏任务与微任务的几种创建方式")]),v._v(" 👇")]),v._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("strong",[v._v("宏任务（"),s("strong",[s("strong",[v._v("Macrotask")])]),v._v("）")])]),v._v(" "),s("th",[s("strong",[v._v("微任务（"),s("strong",[s("strong",[v._v("Microtask")])]),v._v("）")])])])]),v._v(" "),s("tbody",[s("tr",[s("td",[v._v("setTimeout")]),v._v(" "),s("td",[v._v("requestAnimationFrame（有争议）")])]),v._v(" "),s("tr",[s("td",[v._v("setInterval")]),v._v(" "),s("td",[v._v("MutationObserver（浏览器环境）")])]),v._v(" "),s("tr",[s("td",[v._v("MessageChannel")]),v._v(" "),s("td",[v._v("Promise.[ then/catch/finally ]")])]),v._v(" "),s("tr",[s("td",[v._v("I/O，事件队列")]),v._v(" "),s("td",[v._v("process.nextTick（Node环境）")])]),v._v(" "),s("tr",[s("td",[v._v("setImmediate（Node环境）")]),v._v(" "),s("td",[v._v("queueMicrotask")])]),v._v(" "),s("tr",[s("td",[v._v("script（整体代码块）")]),v._v(" "),s("td")])])]),v._v(" "),s("p",[s("strong",[v._v("如何理解 script（整体代码块）是个宏任务呢")]),v._v(" 🤔")]),v._v(" "),s("p",[v._v("实际上如果同时存在两个 script 代码块，会首先在执行第一个 script 代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去清空微任务队列，再去开启第二个 script 代码块的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。")]),v._v(" "),s("p",[s("strong",[v._v("什么是 EventLoop ？")])]),v._v(" "),s("p",[v._v("先来看个图")]),v._v(" "),s("p",[s("img",{attrs:{src:t(372),alt:"image-20211107112127951"}})]),v._v(" "),s("p",[v._v("（细节在宏任务和微任务是否为空的建投指向）")]),v._v(" "),s("ol",[s("li",[s("p",[v._v("判断宏任务队列是否为空")])]),v._v(" "),s("li",[s("ul",[s("li",[v._v("不空 --\x3e 执行最早进入队列的任务 --\x3e 执行下一步")]),v._v(" "),s("li",[v._v("空 --\x3e 执行下一步")])])]),v._v(" "),s("li",[s("p",[v._v("判断微任务队列是否为空")])]),v._v(" "),s("li",[s("ul",[s("li",[v._v("不空 --\x3e 执行最早进入队列的任务 --\x3e "),s("strong",[v._v("继续检查微任务队列空不空")])]),v._v(" "),s("li",[v._v("空 --\x3e 执行下一步")])])])]),v._v(" "),s("p",[v._v("因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 **Js 解析完成后，在异步任务中，会先执行完所有的微任务，**这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回???")]),v._v(" "),s("p",[s("strong",[v._v("同步代码立即执行，微任务宏任务都要进入对应的队列排队")])]),v._v(" "),s("ol",[s("li",[v._v("渲染事件")]),v._v(" "),s("li",[v._v("用户交互事件")]),v._v(" "),s("li",[v._v("js脚本执行 （script加载）")]),v._v(" "),s("li",[v._v("网络请求，文件读写完成事件")]),v._v(" "),s("li",[v._v("延时任务 （setTimoue/setInterval）")])]),v._v(" "),s("p",[v._v("其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:\n将异步回调进行宏任务队列的入队操作。\n将异步回调放到当前宏任务的末尾。")]),v._v(" "),s("p",[v._v("如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。\n为了规避这样的问题，")]),v._v(" "),s("h3",{attrs:{id:"浏览器执行宏任务和微任务的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器执行宏任务和微任务的过程"}},[v._v("#")]),v._v(" 浏览器执行宏任务和微任务的过程")]),v._v(" "),s("ol",[s("li",[v._v("一开始整段脚本作为第一个宏任务执行 (script)")]),v._v(" "),s("li",[v._v("执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列")]),v._v(" "),s("li",[v._v("当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空")]),v._v(" "),s("li",[v._v("执行浏览器 UI 线程的渲染工作")]),v._v(" "),s("li",[v._v("检查是否有Web worker任务，有则执行")]),v._v(" "),s("li",[v._v("执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空")])])])}),[],!1,null,null,null);_.default=r.exports}}]);