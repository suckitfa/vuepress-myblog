### 浏览器执行js的机制
执行上下文 + 调用栈
变量提升： 声明和赋值操作
所谓的变量提升是指，在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提到开头的行为。变量提升后，会给变量设置默认值undefined;

javascript的执行流程
 加载代码阶段-->编译阶段 ---> 执行阶段

 ### 编译阶段
 编译代码，创建
1.  执行上下文
  - 变量环境(this,变量，对象及其函数)
  - 词法环境 (支持块级作用域 let const， 根据作用域块，在词法环境内部维护这一个栈结构)
先在词法环境中查找，然后在变量环境中查找，只要找到就停止查找。
> 块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了

2. 可执行代码


编译成执行上下文
1. 全局
2. 函数
3. eval


调用栈：用来管理函数之间的调用关系
调用一个函数fn，为其创建执行上下文，并压入栈顶，执行fn的代码，执行完毕后，将函数的执行上下文从栈中弹出


作用域：控制着变量和函数的课访问范围和生命周期
全局作用域
函数作用域
块级作用域
```js
if(){}
while(){}
function foo(){}
{}
```

作用域链
执行上下文
 - 变量环境
 - 词法环境

可执行代码



其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

作用域链是由词法作用域决定的。 词法作用域：就是指作用域由代码的声明文位置决定的，词法作用域是静态作用域，通过它能欧预测代码在执行过程中如何查找标识符

作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。

函数执行完毕，销毁指向上下文。
闭包保留着对其上下文的引用。

this和作用域链式两套不同的机制。

执行上下文：变量环境（outer) 词法环境 this

![image-20211102194652646](/Users/bobtang/Library/Application Support/typora-user-images/image-20211102194652646.png)

### 有两种this

- 全局上下文中的this
- 函数的this
> call
> 对象.函数
- eval中的this


### this的设计缺陷
1. 嵌套函数中的this不会从外层函数中继承
```js
var myObj = {
  name:"bob",
  showThis:function() {
    console.log(this);
    function bar(){console.log(this)}
    bar();
  }
}
myObj.showThis();
```
2. 普通函数的this默认指向window;

箭头函数不会创建其自身的执行上下文，其this取决于外部的函数。