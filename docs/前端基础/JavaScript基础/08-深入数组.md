### 类数组转为数组
> 类数组：跟数组一样，key为数字，带length的对象， 但不可以直接调用数组的API
1. `Array.prototype.slice.call(arrayLikeObject)`
2. `Array.from(arrayLikeObject)`
3. 展开运算符: `new Array(...arrayLikeObject)`
4. `Array.prototyep.concat.apply([],arrayLikeObject)`

### forEach
1. 中断该方法中的循环，try...抛出异常
2. 使用every和some替代forEach函数， every中return false,some中return true
自己实现
```js
Array.prototype.myForEach = function (cb)  {
    const thisArray = this;
    const length = thisArray.length;
    let index = -1;
    // 对数组中的每一项元素执行该回调
    while(++index < length) {
        cb(thisArray[index],index,thisArray)
    }
}
```

### JS中判断数组汇总是否包含某个值
- includes
- indexOf
- findIndex
- find
```js
const arr = [1,2,3,4]
arr.find(item=>item>2) // 3
```

### 数组拍平 （多维数组变为一维数组)
- flat(depth=1)
> 局限性：预先知道深度， 默认depth=1；
> 直接给最大的值，Infinity
```js
const testArray = [1,[2,3,[[4]]]]
const flatedArray = testArray.flat(Infinity)
// [1,2,3,4]
```
- 递归 + 循环
> 思路：如果是数组，递归;如果不是数组，直接加入result
```js
function flat(arr) {
    const result = [];
    function flatHelper(arr) {
        for (let i = 0; i < arr.length; ++i) {
            const curItem = arr[i];
            if (Array.isArray(curItem)) {
                // 递归
                flatHelper(curItem);
            } else {
                result.push(curItem);
            }
        }
    }
    flatHelper(arr);
    return result;
}
```
- reduce循环 + 递归
```js
function flat(arr) {
    return arr.reduce((pre,cur)=>{
        return pre.concat(Array.isArray(cur)?flat(cur):cur);
    })
}
```

- some + 扩展运算符
```js
function flat(arr) {
    while (arr.some(Array.isArray)) {
        arr = [].concat(...arr);
    }
    return arr;
}
```
- repalce + split
> replace + JSON.parse
> 思路是：将数组先转为字符串，使用正则替换掉所有的符号:`'['`和`']'`
```js
function flatern(arr) {
    return arr.toString().replace(/\[\]/g,'').split(',')
}
```



### 数组中的高阶函数
> 高阶：接收林另外一个函数作为参数或者返回一个函数的的函数叫做高阶函数
> 理解：一般函数操作的对象都不是函数，而是对象，数组等这些数据....操作函数的函数就是高级的啦

1. map
```js
Array.prototype.myMap = function(cb) {
    const arr = this;
    length = arr.length;
    const result = Array(length);
    let index = -1;
    while (++index < length) {
        // 可以看到回调函数传入三个参数
        result[index] = cb(arr[index], index, arr);
    }
    return result;
}
```
2. reduce
```js
// arr.reduce((累计值，当前值，index,array)=>{

// },初始值)
// 如果不传入初始值，自动以第一个值为初始值
const files = [ 'foo.txt ', '.bar', '   ', 'baz.foo' ];
const filePaths = files.reduce((acc, file) => {
  const fileName = file.trim();
  if(fileName) {
    const filePath = `~/cool_app/${fileName}`;
    acc.push(filePath);
  }
  return acc;
}, []);
// filePaths = [ '~/cool_app/foo.txt', '~/cool_app/.bar', '~/cool_app/baz.foo']
```
```js
Array.prototype.myReduce = function(cb,initVal) {
    const arr = this;
    let index = -1, 
    let accumulator = initVal === 
}
```

3. filter
```js
const todos [{title:'学习',done:true}，{title:'吃饭',done:false}]
const doneList = todos.filter(item => item.done)
console.log(doneList)
```
4. sort
> 不传入参数，直接按字符串排序； 传入一个比较函数 (a,b)=>{}
```js
排序函数返回值
>0 a在b的后面
<0, a在b的前面
```


