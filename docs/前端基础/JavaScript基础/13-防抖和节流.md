### 防抖
防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。

这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。

总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

应用场景
- window:resize,scroll
- mousedown,mousemove
- keydown,keyup ， 搜索框中监听这两个事件可以用来优化
频繁触发的事件

### 简单的防抖
```js
function debounce(fn,delay) {
    let timer = null;
    return function() {
        // 以最新触发的时间为准开始计时
        if(timer) clearTimeout(timer);
        timer = setTimeout(fn,delay);
    }
}
```
### 防抖函数升级
> 支持返回结果，立即执行，this确定，支持参数
> 支持取消
```js
function debounced(fn,delay,immediate = false) {
    let timer = null;
    let result;
    return function() {
        // 保存this
        const context = this;
        const args = arguments;
        if(timer) clearTimeout(timer);
        // 是否立即执行
        if(immediate) {
            // 是否现在触发
            let calledNow = !timer;
            timer = setTimeout(()=>{
                timer = null;
            },delay);
            if(calledNow) result = fn.apply(context,args);
        } else {
            timer = setTimeout(()=>{
                fn.apply(context,args);
            },delay);
        }
        return result;
    }
}
```


### 节流
节流的原理很简单：
如果你持续触发事件，每隔一段时间，只执行一次事件。一般用来降低事件的执行评率。
根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。
#### 节流的定时器实现
```js
function throttle(fn,delay) {
    let timer  = null;
    let previous = 0;
    return function() {
        const context = this;
        const args = arguments;
        // 目前是否存在定时器
        if(!timer) {
            timer = setTimeout(()=>{
                timer = null;
                func.apply(context,args);
            },delay);
        }
    }
}
```

### 参考
- https://github.com/mqyqingfeng/Blog