# 1. JavaScript深入之从原型到原型链
### 实例，原型和原型链
```js
function Person() {

}
var person = new Person();
console.log(person.__proto__ == Person.prototype)
```

![image-20211121213513460](./img/image-prototype.png)

# 2. JavaScript深入之词法作用域和动态作用域
JavaScript使用的是词法作用域，也是静态作用域，白话：根据定义的位置来查找.
作用域链是在函数定义的时候创建的。
```js
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    return f() {
        return scope;
    }
    return f();
}
const res = checkscope();
console.log(res); // local scope
```

```js
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f;
}
const res = checkscope()();
console.log(res); // local scope
```


# 3. JavaScript深入之执行上下文栈
可执行代码
1. 全局代码
2. 函数代码
3. eval代码

### 3.  执行上下文
可执行代码执行前进行代码的执行的准备工作，创建执行上下文 (execution stack)
管理执行上下文的栈叫做执行上下文栈(Execution context stack)

```js
ECStack = [];
```
代码举例
```js
function fun3() {
    console.log('fun3')
}
function fun2() {
    fun3();
}
function fun1() {
    fun2();
}
fun1();
```
对应执行上下文栈
```js
ECStack = [
    fun3Context,
    fun2Context,
    fun1Context,
    globalContext,
]
// 执行过程中使用栈来控制函数执行
```

![image-20211121221322686](./img/image-ECStack.png)

> 这里的anonymous代表的第一个进入执行上下文栈，也就是全局执行上下文





# 4. JavaScript深入之变量对象
- 变量对象 （Varibale object VO)
- 作用域链 (Scope Chian)
- this

全局上下文中的变量对象
> 全局上下文中的变量对象就是全局对象呐！

函数上下文中的变量对象
> 在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。
函数进入执行上下文会分为链各个阶段：分析和执行
1. 进入执行上下文
函数所有的形参:
- 由名称和对应值组成的一个变量对象的属性所创建
- 没有实参，属性值为undefined

函数的声明
- 由名称和对应值组成的一个变量对象的属性被创建
- 后面覆盖前面的

变量的声明
- 名称和undefined
- 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}
foo(1);
```
```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

```
2. 代码执行
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```
例题:
```js
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```
会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。


### 总结
1. 全局上下文的变量对象初始化是全局对象

2. 函数上下文的变量对象初始化只包括 Arguments 对象

3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值

4. 在代码执行阶段，会再次修改变量对象的属性值

