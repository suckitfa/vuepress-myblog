### 防抖 debounce

>  The function is built to limit the number of times a function is called.

防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。
这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。
总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

**应用场景**

- window:resize,scroll
- mousedown,mousemove
- keydown,keyup ， 搜索框中监听这两个事件可以用来优化
频繁触发的事件

### 简单的防抖
```js
funciton debounce(func,time) {
    let timer = null;
    return function() {
        clearTimeout(timer)
        timer = setTimeout(func,time);
    }
}
```
1. this指向问题
2. 支持参数传入
```js
function debounce(func,wait) {
    let timeout = null;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            func.apply(context,args);
        },wait)
    }
}
```
### 防抖函数升级
> 支持返回结果，立即执行，this确定，支持参数
> 支持取消
```js
function debounce(func,wiat,immediate) {
    var timeout,result;
    return function() {
        var context = this;
        var args = arguments;
        if(timeout) clearTimeout(timeout);
        if(immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function() {
                timeout = null;
            },wait);
            if(callNow ) result = func.apply(context,args);
        } else {
            timeout = setTimeout(function() {
                func.apply(context,args);
            },wait);
        }
    }
    return result;
}
```


### 节流
节流的原理很简单：
如果你持续触发事件，每隔一段时间，只执行一次事件。一般用来降低事件的执行评率。
根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。
#### 节流的定时器实现
```js
function throttle(fn,delay) {
    let timer  = null;
    let previous = 0;
    return function() {
        const context = this;
        const args = arguments;
        // 目前是否存在定时器
        if(!timer) {
            timer = setTimeout(()=>{
                timer = null;
                func.apply(context,args);
            },delay);
        }
    }
}
```

### 参考
- https://github.com/mqyqingfeng/Blog
- https://www.educative.io/edpresso/how-to-use-the-debounce-function-in-javascript