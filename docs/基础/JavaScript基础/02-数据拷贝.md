### 数据存储
基本数据类型的值(string,number,boolean,null,undefined,bigint,symbol)存储在`栈内存`中,存储空间大小固定
```js
let a = 1
let b = a;
b = 2
console.log(a) // 1
console.log(b) // 2
```
![image-20211019124005717](./img/primitive-stack.png)

**引用类型的值（object)** 存储在**堆内存**中，因为数据类型嵌套，存储空间大小不固定，对应变量在栈内存中存储这引用类型的地址。
**注意这里是引用类型的值存储在堆内存中，而在栈中存储的是引用类型在堆中的地址。**
```js
const obj1 = {age:18}
const obj2 = obj1
obj2.age = 99
console.log(obj1.age) // 99
console.log(obj2.age) // 99
```
如下图所示，
![image-20211019123737960](./img/obj-stack.png)


### 关于数据的拷贝
拷贝是直接将存储在**栈中的值**复制一份
因此对于基本数据类型的值能够成功复制，而引用类型复制的是**地址**。（如上图所示）

### 深拷贝的实现
1. 借用JSON.stringfy和JSON.parse
> 优点：简单，能够适用大多数场景
> 缺点：忽略undefined属性； 忽略symbol属性，函数，循环引用问题
```js
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj))
}
```

2. 简单实现 
> 考虑到对象的层次嵌套，可以使用递归，首要解决的问题：循环引用引起的**爆栈**问题
> RangeError: Maximum call stack size exceeded
```js
/**
 * 判断是否为引用类型
 * 核心：typeof 特殊处理null,function
 */
function isReferenceValue(val) {
    const type = typeof val;
    return val !== null && (type == 'function' || type == 'object')
}

function deepClone(val, map = new WeakMap()) {
    if (isReferenceValue(val)) {
        const clonedVal = Array.isArray(val) ? [] : {}
        if (map.has(val)) {
            return map.get(val)
        }
        map.set(val, clonedVal)

        for (const key in val) {
            clonedVal[key] = deepClone(val[key], map)
        }
        return clonedVal;
    } else {
        // 非引用类型直接返回
        return val;
    }
}
```
3. 加强版
```js

```
4. 引入lodash库
> 全，稳定
```js
const obj = {
    name: 'Bob',
    city: ['NY', "BY"],
}
obj.self = obj;

const _ = require('lodash')
console.log(_.cloneDeep(obj))
```
### map和weakMap
> weakMap的键是弱引用的，键必须为对象，
> 值可以为任意值
API: 
- clear()
- delete(k)
- get(k)
- has(k)
- set(k)

引入wiki中的解释：在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 （也就是说这玩意随时都可能被回收）


### 参考
- http://www.conardli.top/blog