### 回朔算法
> 核心：for循环里递归，递归之前作出选择，递归之后撤销选择。
> 框架代码。
>
> 决策树为一个多叉树，穷举的过程就是一个多叉树遍历的过程。
```python
result = []
def backtrack(路径,选择列表):
    if 满足条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择（注意排除不合法的选择，比如重复元素等）
        # 递归
        backtrace(路径，选择列表)
        撤销选择
```
维护走过的路径，路径和当前可以做的选择列表，触发结束条件，将路径记录结果集合中
## 经典问题
### 46. 全排列问题

![全排列](/Users/bobtang/Desktop/全排列.png)



> https://leetcode-cn.com/problems/permutations/
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const result = [];
    const track = [];
    function backTrack(nums,track) {
        if(nums.length === track.length) {
            result.push(track.slice());
            return;
        }

        for(let item of nums) {
            //排除不合法的选择：在这里就是不要重复选择同一个
            if(track.indexOf(item) !== -1) continue;
            track.push(item);
            backTrack(nums,track);
            track.pop();
        }
    }
    backTrack(nums,track);
    return result;
};

```

### 51. N皇后问题
```cpp
class Solution {
public:
    // 保存结果
    vector<vector<string>> res;
    vector<vector<string>> solveNQueens(int n) {
        // 初始化空的棋盘，题目中 '.' 代表空
        vector<string> board(n,string(n,'.'));
        backtrack(board,0);
        return res;
    }
    // bord中哪些小于row的行都已经成功放置了皇后
    // 选择条件：第row行所有的列都是放置皇后的选择
    // 结束：row超过board最后一行，说明棋盘放满了
    void backtrack(vector<string>& board, int row) {
        if(row == board.size()) {
            res.push_back(board);
            return;
        }
        int n = board[row].size();
        // 从当前行开始，进行列的选择
        for(int col = 0; col < n ; col ++ ) {
          	// 这里实现了一整个函数isValid来排除不合法的选择
            if(!isValid(board,row,col) ) {
                continue;
            }
            board[row][col] = 'Q';
            // 进入下一行
            backtrack(board,row+1);
            board[row][col] = '.';
        }
    }

    bool isValid(vector<string> & board, int row ,int col) {
        int n = board.size();
        // 同一列
        for(int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') return false;
        }
        // 右上方
        for(int i = row -1,j = col+1; i >=0 && j < n; i--,j++) {
            if(board[i][j] == 'Q') return false;
        }
        // 左上方
        for(int i = row - 1,j  = col - 1; i >=0 && j >= 0; i--,j--) {
            if(board[i][j] == 'Q') return false;
        }
        return true;
    }
};
```

###  组合问题
```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    const result = [];
    const track = [];
    if(k <= 0 || n <= 0) return result;
    function backTrack(start,track) {
        if(k === track.length) {
            result.push(track.slice());
            return;
        }
        for( let i = start; i <= n; i++  ) {
            track.push(i);
            backTrack(i+1,track);
            track.pop();
        }
    }
    return result;
};
```

### 子集问题
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const result = [];
    const track = [];
    function backTrack(nums,track,start) {
        result.push(track.slice());
        for(let i = start; i < nums.length; i++ ) {
            track.push(nums[i]);
            backTrack(nums,track,i+1);
            track.pop();
        }
        return;
    }
    backTrack(nums,track,0);
    return result;
};
```

### 解数独
```java
// i表示行数。j表示列数
void backtrack(char[][] board,int i, int j) {
    int m = 9,n = 9;
    // 穷举到最后一列了就换到下一行重新开始
    if(j == n) {
        backtrack(board,i+1,0);
        return ;
    }

    if(board[i][j] != '.') {
        backtrack(board,i,j+1);
        return;
    }
    for(char ch = '1'; ch <= '9'; ch++ ) {
        // 遇到不合法的字符
        if(!isValid(board,i,j,ch)) continue;
        // 做选择
        board[i][j] = ch;
        // 继续穷举下一个
        backtrack(board,i,j+1);
        // 穷举下一个
        board[i][j] = '.';
    } 
}
```
```js
class Solution {
    public void solveSudoku(char[][] board) {
        if(backTrack(board,0,0)) return;
    }

    boolean backTrack(char[][]board,int i, int j) {
        int m = 9,n = 9;
        if(j == n) {
            // 穷举完当前列，直接换下一类开始
            backTrack(board,i+1,0);
            return true;
        }
        if(i == m) {
            // 找到一个可行解就停止
            return true;
        }
        // 如果当前位置有数字，直接跳过
        if(board[i][j] != '.') {
            backTrack(board,i,j+1);
            return true;
        }
        for(char ch = '1'; ch <= '9'; ch++) {
            if(!isValid(board,i,j,ch) ){
                continue;
            }

            // 作出选择
            board[i][j] = ch;
            // 下一个位置的穷举
            backTrack(board,i,j+1);
            // 撤销选择
            board[i][j] = '.';
        }
        // 穷举完1-9,依然没有可行解
        return false;
    }

    boolean isValid(char[][]board,int r,int c,char n) {
        for(int i = 0; i < 9; i++) {
            // 行是否存在重复
            if(board[r][i] == n) return false;
            if(board[i][c] == n) return false;
            if(board[(r/3)*3+i/3][(c/3)*3 + i % 3] == n) return false;
        }
        return true;
    }
}
```
### 参考
- 《labuladong算法小抄》