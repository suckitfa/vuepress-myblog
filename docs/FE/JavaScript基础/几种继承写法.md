# JavaScript中的几种继承写法

### new操作符干了什么
1. 创建一个空对象 ``obj``
2. 将空对象的[[prototype]]指向构造函数的prototype, ```obj.__proto__=constructorFn.prototype```
3. 将构造函数的this设置为空对象，执行该构造函数，并得到结果```res```
4. 判断构造函数返回结果否为对象，如果是则返回```res```，如果不是则返回自己创建的对象```obj``

```js
function myNew(constructorFn) {
  const obj = {}
  obj.__proto__ = constructorFn.prototype
  const res = constructorFn.call(obj)
  // 确保返回结果不是null
  if(res && typeof res === 'object' ) return res
  return obj
}
```

### 原型链继承

```js
function SuperType() {
  this.colors = ['red','blue']
}
function SubType() {
}
// 原型链改写
SubType.prototype = new SuperTye()
let instance = new SubType()
```

- 优点

1. 实现了对父类原型链上的

- 缺点

1. 原型链上的引用类型数据被所有实例共享
2. 不能给父类构造函数传入参数

### 盗用构造函数继承

> 解决引用值导致的继承问题
>
> 思路：在子类构造函数中调用父类的构造函数，修改this

```js
1. 支持传入参数给父类构造函数
2. 
function SuperType(name) {
  this.colors = ['red','blue']
  this.name = name
}
function SubType(name) {
  SuperType.call(this,name)
}
// 原型链改写
SubType.prototype = new SuperTye()
let instance = new SubType()
```

问题： 函数必须定义在构造函数中，函数不能复用。子类不能够访问父类原型上的方法。

### 组合继承

> 原型链继承适合复用函数
>
> 盗用构造函数适合解决属性继承问题
>
> 思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。

```js
function SuperType(name) {
  this.name = name
  this.colors = ['red','blue','green']
}
SuperType.prototype.sayName = function () {
  console.log(this.name)
}

function SubType(name,age) {
  // 盗用构造函数
  SuperType.call(this,name)
  this.age = age
}
// 改写原型链，继承定义在父类原型链上的方法和属性
SubType.prototype = new SuperType()
SubType.prototype.sayAge = function () {
  console.log(this.age)
}

let obj1 = new SubType('bob',20)
obj1.sayName()
obj2.sayAge()

let obj2 = new SubType('evan',22)
obj2.sayName()
obj2.sayAge()
```

### 原型式继承

> 适合基于某个对象来实现下一个对象

```js
function object(o) {
  function F(){}
  // 这里只做了浅复制
  F.prototype = o
  return new F()
}
// 官方API
Object.create(obj)

// 传入两个 obj
Object.create(ojb,{
	name:{
    value:'Greg'
  }
})
```

问题：引用值问题

### 寄生式继承

```js
function createAnother(original) {
  let clone = object(original)
  clone.sayHi = function() {
    console.log('hi')
  }
  return clone
}
```

### 寄生组合式继承

```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}
function inheritProtype(subType,superType) {
  let prototype = object(superType.prototype)
  prototype.constructor = subType
  subType.prototype = prototype
}

function SuperType(name) {
  this.name = name
  this.colors = ['red','blue']
}
SuperType.prototype.sayName = function() {
  console.log(this.name)
}
function SubType(name,age) {
  SuperType.call(this,name)
  this.age = age;
}
inheritPrototype(SubType,SuperType)
SubType.prototype.sayAge = function() {
  console.log(this.age)
}
```

### ES6中的class语法糖

> constructor
>
> method
>
> get 
>
> set
>
> static

```js
class Person {
  constructor(name) {
    this.name = name
  }
}
let bob = new Person('bob')
console.log(bob) // {name:"bob"}
```

