# JavaScript中的几种继承写法
> 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 - 《你不知道的JavaScript》
>我的理解： 更好的组织代码，实现代码复用.
### new操作符干了什么
1. 创建一个空对象 ``obj``
2. 将空对象的[[prototype]]指向构造函数的prototype, ```obj.__proto__=constructorFn.prototype```
3. 将构造函数的this设置为空对象，执行该构造函数，并得到结果```res```
4. 判断构造函数返回结果否为对象，如果是则返回```res```，如果不是则返回自己创建的对象```obj``

```js
function myNew(constructorFn) {
  const obj = {}
  obj.__proto__ = constructorFn.prototype
  const res = constructorFn.call(obj)
  // 确保返回结果不是null
  if(res && typeof res === 'object' ) return res
  return obj
}
```

### 原型链继承
> 改写子类的原型指向父类对象实例
```js
function SuperType() {
  this.colors = ['red','blue']
}
function SubType() {
}
// 原型链改写
SubType.prototype = new SuperTye()
let instance = new SubType()
```
- 优点
1. 实现了对父类原型链上的属性和方法的继承
- 缺点
1. 原型链上的引用类型数据被所有实例共享
2. 不能给父类构造函数传入参数

### 盗用构造函数继承
> 解决引用值导致的继承问题
> 思路：在子类构造函数中调用父类的构造函数，修改this

```js
1. 支持传入参数给父类构造函数
2. 
function SuperType(name) {
  this.colors = ['red','blue']
  this.name = name
}
// 结合new的原理来理解
function SubType(name) {
  SuperType.call(this,name)
}
```
问题： 函数必须定义在构造函数中，实际上每次都是重新开辟空间。（没有到达真正意义上的复用）

### 组合继承

> 原型链继承适合复用函数
> 盗用构造函数适合解决属性继承问题
> 思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。

```js
function SuperType(name) {
  this.name = name
  this.colors = ['red','blue','green']
}
SuperType.prototype.sayName = function () {
  console.log(this.name)
}

function SubType(name,age) {
  // 盗用构造函数
  SuperType.call(this,name)
  this.age = age
}
// 改写原型链，继承定义在父类原型链上的方法和属性
SubType.prototype = new SuperType()
// 不要丢失了constructor
SubType.prototype.constructor = SubType
SubType.prototype.sayAge = function () {
  console.log(this.age)
}
```

### 原型式继承
> 适合基于某个对象来实现下一个对象

```js
function object(o) {
  function F(){}
  // 这里只做了浅复制
  F.prototype = o
  return new F()
}
// 官方API
Object.create(obj)

// 传入两个 obj
Object.create(ojb,{
	name:{
    value:'Greg'
  }
})
```
问题：引用值问题
### 寄生式继承
```js
function createAnother(original) {
  let clone = Object.create(original)
  clone.sayHi = function() {
    console.log('hi')
  }
  return clone
}
```
缺点：每次创建对象时都会创建一次方法
### 寄生组合式继承
```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}
function inheritProtype(subType,superType) {
  let prototype = object(superType.prototype)
  prototype.constructor = subType
  subType.prototype = prototype
}

function SuperType(name) {
  this.name = name
  this.colors = ['red','blue']
}
SuperType.prototype.sayName = function() {
  console.log(this.name)
}
function SubType(name,age) {
  SuperType.call(this,name)
  this.age = age;
}
inheritPrototype(SubType,SuperType)
SubType.prototype.sayAge = function() {
  console.log(this.age)
}
```
优点：只调用一次父构造函数
### ES6中的class语法糖
> constructor
>
> method
>
> get 
>
> set
>
> static

```js
class Person {
  constructor(name) {
    this.name = name
  }
}
let bob = new Person('bob')
console.log(bob) // {name:"bob"}
```

### 来自红宝书